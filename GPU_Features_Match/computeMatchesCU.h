#pragma once
#ifndef _COMPUTE_FEATURES_CU_H_
#define _COMPUTE_FEATURES_CU_H_

#include <Eigen/Dense>
#include <omp.h>
#include "openMVG/types.hpp"
#include "openMVG/system/timer.hpp"
#include "openMVG/stl/dynamic_bitset.hpp"
#include "openMVG/matching/indMatch.hpp"
#include "openMVG/matching/indMatch_utils.hpp"
#include "openMVG/sfm/pipelines/sfm_regions_provider.hpp"
#include "third_party/stlplus3/filesystemSimplified/file_system.hpp"
//#include "cascade_hasher_GPU.hpp"
#include <string>

using namespace openMVG;

namespace computeMatches {

	using BaseMat = Eigen::Matrix<unsigned char, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor>;

	const int group_count = 6;
	const int block_count_per_group = 4;
	const int image_count_per_block = 3;
	const int image_count_per_group = 12;
	const int descriptionDimension = 128;

	const float fDistRatio = 0.8f;
	const int openmp_thread_num = omp_get_max_threads();
	/*const std::string sSfM_Data_FilenameDir_father = stlplus::folder_up(imageInputDir, 4) +
		"/imageData/tianjin/";

	const std::string sMatchesOutputDir_father = stlplus::folder_up(imageInputDir, 4) +
		"/imageData/tianjin/";*/

	struct HashedDescription {
		// Hash code generated by the primary hashing function.
		stl::dynamic_bitset hash_code;
		
		// Each bucket_ids[x] = y means the descriptor belongs to bucket y in bucket
		// group x.
		std::vector<uint16_t> bucket_ids;
	};

	struct HashedDescriptions {
		// The hash information.
		std::vector<HashedDescription> hashed_desc;
		 
		using Bucket = std::vector<int>;
		// buckets[bucket_group][bucket_id] = bucket (container of description ids).
		std::vector<std::vector<Bucket>> buckets;
	};

	////////////////////////////
	/*
	compute HashCode
	*/
	///////////////////////////
	
	//geometric model
	//fundamental matrix、essential matrix、homography matrix
	//angular essential matrix、ortho essential matrix
	enum EGeometricModel
	{
		FUNDAMENTAL_MATRIX = 0,
		ESSENTIAL_MATRIX = 1,
		HOMOGRAPHY_MATRIX = 2,
		ESSENTIAL_MATRIX_ANGULAR = 3,
		ESSENTIAL_MATRIX_ORTHO = 4,
		ESSENTIAL_MATRIX_UPRIGHT = 5
	};
	//匹配对模式
	//详细匹配对、临近匹配对、从文件中读取的匹配对
	enum EPairMode
	{
		PAIR_EXHAUSTIVE = 0,
		PAIR_CONTIGUOUS = 1,
		PAIR_FROM_FILE = 2
	};
	/// Compute corresponding features between a series of views:
	/// - Load view images description (regions: features & descriptors)
	/// - Compute putative local feature matches (descriptors matching)
	/// - Compute geometric coherent feature matches (robust model estimation from putative matches)
	/// - Export computed data
	void test();

	void computeZeroMeanDescriptors
	(
		Eigen::VectorXf &_zero_mean_descriptor,		//输出结果
		const sfm::Regions_Provider & regions_provider,
		const Pair_Set & pairs
	);
	void computeHashes
	(
		std::vector<Eigen::Map<BaseMat>> mat_I_vec,
		std::map<IndexT, HashedDescriptions> hashed_base_,
		const Eigen::VectorXf & zero_mean_descriptor,
		// The number of bucket bits.
		int nb_bits_per_bucket_,
		// The number of dimensions of the Hash code.
		int nb_hash_code_,
		// The number of bucket groups.
		int nb_bucket_groups_,
		// The number of buckets in each group.
		int nb_buckets_per_group_,
		Eigen::MatrixXf primary_hash_projection_,
		std::vector<Eigen::MatrixXf> secondary_hash_projection_
	);

	int computeMatchesGPU
	(
		const sfm::Regions_Provider & regions_provider,
		Pair_Set &pairs,
		openMVG::matching::PairWiseMatches &map_PutativesMatches,
		C_Progress *my_progress_bar
	);
	int computeMatchesMVG
	(
		std::string sSfM_Data_Filename,
		std::string sMatchesDirectory,
		std::string sPredefinedPairList,
		std::string sGeometricModel
	);
	
	

}//namespace computeMatches



#endif // !_COMPUTE_FEATURES_CU_H_
